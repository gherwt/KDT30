## 2 차원 리스트

리스트 안의 리스트

arr = [[0, 1, 2, 3], [4, 5, 6, 7]]

```
arr = [[0, 1, 2, 3], 

[4, 5, 6, 7]]

```

차원에 따라 index를 선언 세로 길이, 가로길이를 필요로 한다.

10x10 체스판

동일한 list로 반복해서 만들기

리스트 반복-> 곰셈 연산을 활용한다.

[1, 2, 3] in range(3)

곱셈을 활용 반복구조 만들 수 있고 초기화할 수 있다.

한큐에 list n 번 반복하는 것을 주로 사용할 것 함축한 것만큼 리스트가 반복된다.

list 가 n 번 반복되면 n개의 행을 가지는 list

원하는 데이터 찾기

순회 방법

행 우선

2중 반복문

열 우선

열부터 조사 2중 반복문으로 구연 행열 위치를 바꿔서 진행 할 수 있다.

지그재그

열을 참조하는 index를 잘 파악해야 한다.


델타를 이용한 2차 list 탐색

인접 리스트 요소를 탐색할 때 사용

x, y의 차이를 저장한 list 로 구현 -> 특정 원소의 상하좌우 
위치한 원소에 접근 -> index 값을 잘 제한해야한다.

전치행렬 - 행과 열의 값이 반대인 행렬를 의미

zip() -> map 과 비슷 동일한 개수로 이루어진 자료형들을 묶어주는 역할을 하는 함수. 전치를 쉽게 만드는 방법.


## 검색

원하는 항목을 찾는 작업 -> 탐색키를 가진 항복 자료 구별 인식 키

순차 검색 

일렬로 되어 있는 자료를 검색, 순서에 따라 비교횟수가 결정된다.

n+1/2

in 연산자 O(n) 개의 연산 횟수를 가진다.


정렬/ 비정렬

첫번째 원소부터 순서대로 키값이 동인한 원소가 있는지를 비교


이진 검색 

절반값을 설정하고 비교하면서 자료 수를 줄여나간다.

O(log2n)

하지만 데이터가 정렬되어 있어야 한다.

증앙 값으로 계속 비교하면서 특정값으로 줄여나간다.


인덱스

```
# [
#   ] 이런 모양이다.

# list 는 가로부터 읽어 준다.
# matrix[x][y] => 2,1 ?? -> [row][col]
# 행 가 row // 열 col

# matrix = [[(x for x in  range (y*5, (y+1)*5)] for y in range(5)]

row, col = 3, 2

drows = [-1, 1, 0, 0]
dcols = [0, 0, -1, 1]

print(matrix[row][col])
for idx in range(4):
    new_r = row + drows[idx]
    new_c = col + dcols[idx]

    if 0 <= new_r <= N and 0 <= new_c <= N and
# 중앙값 2  1
# 상  row + 1 col + 0
# 하  row - 1 col + 0
# 좌  row + 0 col - 1
# 우  row + 0 col + 1
# drows = [-1, 1, 0, 0]
# dcols = [0, 0, =1, 1]

```